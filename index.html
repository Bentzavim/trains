<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Train Departures</title>
    <!-- Load Tailwind CSS for layout -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Import retro pixel font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- Custom styles for the retro board -->
    <style>
        /* Apply the pixel font and retro colours */
        body {
            font-family: 'VT323', monospace;
            background-color: #000;
            color: #f9b200; /* Amber/Yellow */
            text-shadow: 0 0 3px #f9b200, 0 0 1px #f9b200;
        }

        /* Animation for the board flicker */
        @keyframes flicker {
            0%, 100% { 
                opacity: 1; 
                box-shadow: 0 0 10px #f9b200;
            }
            50% { 
                opacity: 0.98; 
                box-shadow: 0 0 15px #f9b200;
            }
        }

        /* The main board container */
        .departure-board {
            border: 8px solid #333;
            background-color: #0a0a0a; /* Very dark grey, not pure black */
            animation: flicker 2s infinite;
            box-shadow: 0 0 10px #f9b200; /* Add a glow to the board itself */
        }
        
        .header-title {
            color: #ffffff;
            text-shadow: 0 0 5px #ffffff, 0 0 2px #ffffff;
        }
        
        .clock-text {
            color: #eee;
            text-shadow: 0 0 3px #eee;
        }

        /* Status colours */
        .status-ontime { 
            color: #00ff00; /* Bright Green */
            text-shadow: 0 0 3px #00ff00;
        }
        .status-delayed { 
            color: #ff0000; /* Bright Red */
            text-shadow: 0 0 3px #ff0000;
        }
        .status-cancelled { 
            color: #ff0000; /* Bright Red */
            text-shadow: 0 0 3px #ff0000;
        }
        .status-later-today {
            color: #00ccff; /* Bright Blue */
            text-shadow: 0 0 3px #00ccff;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div class="departure-board p-6 rounded-lg w-full max-w-lg">

        <div class="flex justify-between items-center mb-4 border-b-4 border-gray-700 pb-2">
            <h1 class="header-title text-4xl font-bold">
                BUSHEY (BSH)
            </h1>
            <div class="text-right text-xl clock-text">
                <span id="current-time">00:00:00</span><br>
                <span id="last-updated" class="text-sm">Last updated: ---</span>
            </div>
        </div>
        
        <div class="flex text-xl text-gray-400 mb-2">
            <span class="w-1/4">Time</span>
            <span class="w-1/2">Destination</span>
            <span class="w-1/4 text-right">Status</span>
        </div>

        <div id="train-list" class="space-y-3">
            <!-- Train cards will be dynamically inserted here by JavaScript -->
        </div>

    </div>

    <script>
        // --- CONFIGURATION ---
        const DEPARTURE_STATION_CODE = "BSH"; 
        const DESTINATION_STATION_CODE = "EUS";
        const DESTINATION_FILTER_NAME = "london euston"; // Name to filter by
        const MORNING_START_TIME = "06:00"; // Time to check from if no trains are found
        const TRAIN_COUNT = 2; // How many trains to show
        const FALLBACK_TRAIN_COUNT = 10; // How many trains to *ask for* in the fallback to find timetabled ones
        // --- END CONFIGURATION ---

        // --- REAL API FUNCTION (HUXLEY 2) ---
        // Now accepts an optional options object { time, date, count, noDestinationFilter }
        async function fetchRealTrainData(fromStation, toStation, count, options = {}) {
            
            // Use count from options if provided, otherwise default
            const queryCount = options.count || count;
            
            // NEW: Build URL based on whether a destination filter is applied
            let apiUrl = `https://huxley2.azurewebsites.net/departures/${fromStation}`;
            if (options.noDestinationFilter) {
                apiUrl += `/${queryCount}`; // e.g., /departures/BSH/10
                console.log("Fetching all departures (no destination filter)");
            } else {
                apiUrl += `/to/${toStation}/${queryCount}`; // e.g., /departures/BSH/to/EUS/2
            }
            
            let params = new URLSearchParams();

            if (options.time) {
                console.log(`...starting from ${options.time}`);
                params.append('time', options.time);
            }
            if (options.date) {
                console.log(`...on date ${options.date}`);
                params.append('date', options.date);
            }

            // Build final URL
            const finalUrl = params.toString() ? `${apiUrl}?${params.toString()}` : apiUrl;
            console.log(`Fetching: ${finalUrl}`);

            try {
                const response = await fetch(finalUrl);
                if (!response.ok) {
                    const errorText = await response.text(); 
                    console.error("API Response not OK:", response.status, errorText);
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                const apiData = await response.json();
                console.log("API Response:", apiData); 
                
                if (!apiData.trainServices || apiData.trainServices.length === 0) {
                    if (apiData.crs && apiData.trainServices === null) {
                         console.warn("Huxley API reports no train services.", apiData);
                    } else {
                        console.warn("No trainServices array found in API response", apiData);
                    }
                    return [];
                }

                // --- Data Mapping ---
                return apiData.trainServices.map(service => {
                    const scheduled = service.std;
                    const expected = service.etd;
                    const destination = service.destination && service.destination.length > 0 
                                      ? service.destination[0].locationName 
                                      : "Unknown";
                    // UPDATED: Check for operatorName, operator, or toc (Train Operating Company)
                    const operator = service.operatorName || service.operator || service.toc || "Unknown";
                    
                    if (!scheduled) {
                         console.warn("Service missing scheduled time (std):", service);
                         return null;
                    }

                    let delay = 0;
                    let status = "On time";

                    if (expected !== "On time" && expected !== "Cancelled" && expected !== "Delayed" && expected !== scheduled) {
                        const std = parseTimeString(scheduled);
                        const etd = parseTimeString(expected);
                        delay = getMinutesDifference(etd, std);
                        status = "Delayed";
                    } else if (expected !== "On time") {
                        status = expected;
                    }

                    return {
                        id: service.serviceID,
                        scheduled: scheduled,
                        destination: destination, // We filter on this later
                        operator: operator,
                        delay: delay,
                        status: status
                    };
                }).filter(Boolean); // Filter out any null services

            } catch (error) {
                console.error("Failed to fetch real train data:", error);
                throw error; 
            }
        }


        // --- UTILITY FUNCTIONS ---
        function parseTimeString(timeStr) {
            const [hours, minutes] = timeStr.split(':');
            const date = new Date();
            date.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            return date;
        }

        function formatTime(date) {
            return date.toLocaleTimeString('en-GB'); 
        }

        function getMinutesDifference(dateFuture, dateNow) {
            const diffMs = dateFuture.getTime() - dateNow.getTime();
            return Math.ceil(diffMs / (1000 * 60));
        }

        /**
         * Gets today's date in YYYY-MM-DD format, corrected for local timezone.
         */
        function getTodayISO() {
            const today = new Date();
            // Correct for local timezone to avoid off-by-one day errors
            const offset = today.getTimezoneOffset();
            const todayLocal = new Date(today.getTime() - (offset * 60 * 1000));
            return todayLocal.toISOString().split('T')[0];
        }

        // --- MAIN APP LOGIC ---

        const trainListElement = document.getElementById('train-list');
        const currentTimeElement = document.getElementById('current-time');
        const lastUpdatedElement = document.getElementById('last-updated');

        async function updateDepartureBoard() {
            const now = new Date();
            currentTimeElement.textContent = formatTime(now);
            lastUpdatedElement.textContent = `Last updated: ${formatTime(now)}`;
            
            trainListElement.innerHTML = '<div class="text-center text-xl">Updating...</div>';

            let trainData = [];
            let fetchError = false;
            let isForLaterToday = false; 

            try {
                // --- 1. Try to get "next" trains (e.g., .../BSH/to/EUS/2) ---
                trainData = await fetchRealTrainData(
                    DEPARTURE_STATION_CODE, 
                    DESTINATION_STATION_CODE, 
                    TRAIN_COUNT
                );
            } catch (error) {
                console.error("Error in fetchRealTrainData (next), will try fallback.", error);
                fetchError = true;
            }

            // --- 2. If "next" finds nothing, try full day search (e.g., .../BSH/10?time=06:00&date=2025-11-01) ---
            if (!fetchError && (!trainData || trainData.length === 0)) {
                console.warn(`No 'next' services found. Trying from ${MORNING_START_TIME}...`);
                isForLaterToday = true; // Flag this
                
                const todayStr = getTodayISO(); // Get YYYY-MM-DD for today
                
                try {
                    trainListElement.innerHTML = `<div class="text-center text-xl status-later-today">No trains now. Checking timetable from ${MORNING_START_TIME}...</div>`;
                    
                    // NEW: Fetch ALL departures from BSH, not just to EUS
                    const allDepartures = await fetchRealTrainData(
                        DEPARTURE_STATION_CODE, 
                        DESTINATION_STATION_CODE, // Still pass EUS, but it's ignored by function
                        TRAIN_COUNT, 
                        { 
                            time: MORNING_START_TIME, 
                            date: todayStr,
                            count: FALLBACK_TRAIN_COUNT, // Ask for 10
                            noDestinationFilter: true // IMPORTANT: Tell function to not use destination
                        }
                    );

                    // NEW: Filter the results locally
                    if (allDepartures && allDepartures.length > 0) {
                        console.log(`Fetched ${allDepartures.length} departures, filtering for ${DESTINATION_FILTER_NAME}...`);
                        trainData = allDepartures.filter(train => {
                            return train.destination.toLowerCase().includes(DESTINATION_FILTER_NAME);
                        });
                        console.log(`Found ${trainData.length} trains to ${DESTINATION_FILTER_NAME}.`);
                    }

                } catch (error) {
                     console.error("Error in fetchRealTrainData (today)", error);
                     fetchError = true; // Set fetch error for final fallback
                }
            }

            // --- 3. Error display (if all else fails) ---
            if (fetchError || !trainData || trainData.length === 0) {
                 if (fetchError) {
                     // This means the API call itself failed (e.g., network down)
                     trainListElement.innerHTML = '<div class="text-center text-3xl status-delayed">DATA ERROR</div><div class="text-center text-xl text-gray-400">Could not connect to server.</div>';
                 } else {
                     // This means the API call worked, but no trains were returned OR our filter found nothing.
                     trainListElement.innerHTML = `<div class="text-center text-3xl status-later-today">NO SERVICES FOUND</div><div class="text-center text-xl text-gray-400">No services found for today.</div>`;
                 }
                 return; // Stop execution
            }

            // We only want the first TRAIN_COUNT trains, even if we fetched 10
            const limitedData = trainData.slice(0, TRAIN_COUNT);
            
            // Clear the list (but keep "later today" header if it exists)
            if (isForLaterToday) {
                trainListElement.innerHTML = `<div class="text-center text-2xl status-later-today mb-2">First trains from ${MORNING_START_TIME}</div>`;
            } else {
                trainListElement.innerHTML = '';
            }

            if (limitedData.length === 0) {
                 trainListElement.innerHTML += `<div class="text-center text-xl">No departures found.</div>`;
                 return;
            }
            
            // Loop over limitedData
            limitedData.forEach(train => {
                const scheduledTime = parseTimeString(train.scheduled);
                
                let statusText = train.status;
                let statusColor = "status-ontime";
                let timeUntilText = ""; 
                
                // --- UPDATED: Logic for today vs later today ---
                if (isForLaterToday) {
                    // If we are showing trains for later, just show status
                    timeUntilText = "Later Today"; 
                    if (train.status === "Cancelled") {
                        statusColor = "status-cancelled";
                    }
                } else {
                    // Original logic for "minutes until"
                    let minutesUntil = 0; 
                    if (train.status === "On time") {
                        minutesUntil = getMinutesDifference(scheduledTime, now);
                    } else if (train.status === "Cancelled") {
                        statusColor = "status-cancelled";
                        minutesUntil = -999;
                    } else if (train.delay > 0) {
                        const actualDepartureTime = new Date(scheduledTime.getTime() + train.delay * 60000);
                        minutesUntil = getMinutesDifference(actualDepartureTime, now);
                        statusText = `Delayed ${train.delay} min`;
                        statusColor = "status-delayed";
                    } else {
                        statusText = "Delayed";
                        statusColor = "status-delayed";
                        minutesUntil = getMinutesDifference(scheduledTime, now);
                    }

                    timeUntilText = `In ${minutesUntil} mins`;
                    if (minutesUntil <= 0 && train.status !== "Cancelled") {
                         // Catch trains that are due or just departed
                        if (minutesUntil > -10) {
                           timeUntilText = "Departed";
                           statusText = "---";
                           statusColor = "text-gray-500";
                        } else {
                           timeUntilText = "Departed";
                        }
                    } else if (train.status === "Cancelled") {
                        timeUntilText = "---";
                    }
                    
                    // Special case for "Due"
                    if (minutesUntil > 0 && minutesUntil <= 1) {
                        timeUntilText = "Due";
                    }
                }
                
                const row = document.createElement('div');
                row.className = "mb-3"; 
                
                row.innerHTML = `
                    <!-- Main line -->
                    <div class="flex text-3xl">
                        <span class="w-1/4">${train.scheduled}</span>
                        <span class="w-1/2">${train.destination}</span>
                        <span class="w-1/4 text-right ${statusColor}">${statusText}</span>
                    </div>
                    <!-- Sub line -->
                    <div class="flex text-xl text-gray-400 pb-2 border-b-2 border-gray-800 border-dashed">
                        <span class="w-1/4">&nbsp;</span> <!-- Spacer -->
                        <span class="w-1/2">${train.operator}</span>
                        <span class="w-1/4 text-right">${timeUntilText}</span>
                    </div>
                `;
                
                // Only show if it's for later today OR hasn't long departed today
                if (isForLaterToday || getMinutesDifference(scheduledTime, now) > -10) {
                    trainListElement.appendChild(row);
                }
            });
        }

        // --- INITIALIZE APP ---
        updateDepartureBoard();
        setInterval(updateDepartureBoard, 30000); // Check every 30 seconds
        setInterval(() => {
            // THIS IS THE FIX: new Date()
            currentTimeElement.textContent = formatTime(new Date());
        }, 1000);

    </script>

</body>
</html>
